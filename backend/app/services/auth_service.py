import logging
import hashlib
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from passlib.context import CryptContext
from jose import JWTError, jwt
from fastapi import HTTPException, status
from sqlalchemy import text

from ..core.oracle_config import oracle_manager
from ..schemas.user_schemas import UserCreate, UserLogin, UserResponse, TipoUsuario, StatusUsuario, UserProfileUpdate

# Configuração de logging
logger = logging.getLogger(__name__)

# Configurações de segurança
SECRET_KEY = "nauru_yvy_secret_key_development_bityx_2024"  # Em produção, usar variável de ambiente
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 480  # 8 horas

# Context para hash de senhas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class AuthService:
    """Serviço de autenticação com Oracle - padrão bancário"""
    
    def __init__(self):
        self.ensure_tables_exist()
    
    def ensure_tables_exist(self):
        """Garantir que as tabelas necessárias existem no Oracle"""
        try:
            # Verificar se as tabelas existem (ordem importante: TERRITORIOS primeiro)
            tables_to_check = ["TERRITORIOS", "USUARIOS"]
            
            for table in tables_to_check:
                if not oracle_manager.check_table_exists(table):
                    logger.warning(f"⚠️ Tabela {table} não encontrada, criando...")
                    self.create_table(table)
                else:
                    logger.info(f"✅ Tabela {table} existe")
                    
        except Exception as e:
            logger.error(f"❌ Erro ao verificar/criar tabelas: {e}")
    
    def create_table(self, table_name: str):
        """Criar tabelas necessárias no Oracle"""
        try:
            if table_name == "TERRITORIOS":
                create_query = """
                CREATE TABLE TERRITORIOS (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    NOME VARCHAR2(200) NOT NULL,
                    ESTADO VARCHAR2(50) NOT NULL,
                    MUNICIPIO VARCHAR2(100) NOT NULL,
                    AREA_HECTARES NUMBER(10,2),
                    POPULACAO NUMBER(10),
                    COORDENADAS_LAT NUMBER(10,8),
                    COORDENADAS_LNG NUMBER(11,8),
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT UK_TERRITORIOS_NOME UNIQUE (NOME, ESTADO)
                )
                """
                
            elif table_name == "USUARIOS":
                create_query = """
                CREATE TABLE USUARIOS (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    NOME VARCHAR2(100) NOT NULL,
                    EMAIL VARCHAR2(150) NOT NULL UNIQUE,
                    SENHA_HASH VARCHAR2(255) NOT NULL,
                    TIPO_USUARIO VARCHAR2(50) NOT NULL,
                    TERRITORIO_ID NUMBER,
                    TELEFONE VARCHAR2(20),
                    NOME_SOCIAL VARCHAR2(100),
                    NOME_INDIGENA VARCHAR2(100),
                    IDADE NUMBER(3),
                    PRINCIPAL_ATUACAO VARCHAR2(200),
                    ALDEIA_COMUNIDADE VARCHAR2(200),
                    LOCALIZACAO_TERRITORIO VARCHAR2(200),
                    ACEITE_LGPD NUMBER(1) DEFAULT 0,
                    STATUS VARCHAR2(20) DEFAULT 'ativo',
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    ULTIMA_ATUALIZACAO TIMESTAMP,
                    CONSTRAINT CHK_TIPO_USUARIO 
                        CHECK (TIPO_USUARIO IN ('administrador', 'lider_territorial', 'monitor_ambiental', 'membro_comunidade', 'pesquisador')),
                    CONSTRAINT CHK_STATUS_USUARIO 
                        CHECK (STATUS IN ('ativo', 'inativo', 'pendente', 'bloqueado')),
                    CONSTRAINT CHK_ACEITE_LGPD
                        CHECK (ACEITE_LGPD IN (0, 1)),
                    CONSTRAINT CHK_IDADE
                        CHECK (IDADE >= 0 AND IDADE <= 150)
                )
                """
            
            oracle_manager.execute_insert(create_query, {})
            logger.info(f"✅ Tabela {table_name} criada com sucesso")
            
            # Inserir território padrão se for a primeira vez
            if table_name == "TERRITORIOS":
                self.create_default_territory()
                
        except Exception as e:
            logger.error(f"❌ Erro ao criar tabela {table_name}: {e}")
            raise
    
    def create_default_territory(self):
        """Criar território padrão"""
        try:
            territory_query = """
                INSERT INTO TERRITORIOS (NOME, ESTADO, MUNICIPIO, AREA_HECTARES, POPULACAO)
                VALUES (:nome, :estado, :municipio, :area, :populacao)
            """
            
            territory_data = {
                "nome": "Território de Desenvolvimento Naurú Yvy",
                "estado": "São Paulo",
                "municipio": "São Paulo",
                "area": 1000.0,
                "populacao": 500
            }
            
            oracle_manager.execute_insert(territory_query, territory_data)
            logger.info("✅ Território padrão criado")
            
        except Exception as e:
            logger.warning(f"⚠️ Território padrão pode já existir: {e}")
    
    def hash_password(self, password: str) -> str:
        """Gerar hash seguro da senha"""
        return pwd_context.hash(password)
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verificar senha"""
        return pwd_context.verify(plain_password, hashed_password)
    
    def create_access_token(self, data: dict) -> str:
        """Criar token JWT"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verificar e decodificar token JWT"""
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            return payload
        except JWTError:
            return None
    
    def get_user_by_email(self, email: str) -> Optional[Dict[str, Any]]:
        """Buscar usuário por email"""
        try:
            query = """
                SELECT u.ID, u.NOME, u.EMAIL, u.SENHA_HASH, u.TIPO_USUARIO, 
                       u.TERRITORIO_ID, u.TELEFONE, u.NOME_SOCIAL, u.NOME_INDIGENA,
                       u.IDADE, u.PRINCIPAL_ATUACAO, u.ALDEIA_COMUNIDADE,
                       u.LOCALIZACAO_TERRITORIO, u.ACEITE_LGPD, u.STATUS, u.DATA_CRIACAO,
                       t.NOME as TERRITORIO_NOME
                FROM USUARIOS u
                LEFT JOIN TERRITORIOS t ON u.TERRITORIO_ID = t.ID
                WHERE UPPER(u.EMAIL) = UPPER(:email)
                AND u.STATUS = 'ativo'
            """
            
            result = oracle_manager.execute_query(query, {"email": email})
            
            if result:
                row = result[0]
                return {
                    "id": row[0],
                    "nome": row[1],
                    "email": row[2],
                    "senha_hash": row[3],
                    "tipo_usuario": row[4],
                    "territorio_id": row[5],
                    "telefone": row[6],
                    "nome_social": row[7],
                    "nome_indigena": row[8],
                    "idade": row[9],
                    "principal_atuacao": row[10],
                    "aldeia_comunidade": row[11],
                    "localizacao_territorio": row[12],
                    "aceite_lgpd": bool(row[13]) if row[13] is not None else False,
                    "status": row[14],
                    "data_criacao": row[15],
                    "territorio_nome": row[16]
                }
            
            return None
            
        except Exception as e:
            logger.error(f"❌ Erro ao buscar usuário por email: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )
    
    def register_user(self, user_data: UserCreate) -> Dict[str, Any]:
        """Registrar novo usuário"""
        try:
            # Verificar se email já existe
            existing_user = self.get_user_by_email(user_data.email)
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Email já cadastrado no sistema"
                )
            
            # Hash da senha
            hashed_password = self.hash_password(user_data.senha)
            
            # Inserir usuário
            insert_query = """
                INSERT INTO USUARIOS (
                    NOME, EMAIL, SENHA_HASH, TIPO_USUARIO, 
                    TERRITORIO_ID, TELEFONE, NOME_SOCIAL, NOME_INDIGENA,
                    IDADE, PRINCIPAL_ATUACAO, ALDEIA_COMUNIDADE, 
                    LOCALIZACAO_TERRITORIO, ACEITE_LGPD, STATUS
                ) VALUES (
                    :nome, :email, :senha_hash, :tipo_usuario, 
                    :territorio_id, :telefone, :nome_social, :nome_indigena,
                    :idade, :principal_atuacao, :aldeia_comunidade,
                    :localizacao_territorio, :aceite_lgpd, 'ativo'
                )
            """
            
            user_params = {
                "nome": user_data.nome,
                "email": user_data.email.lower(),
                "senha_hash": hashed_password,
                "tipo_usuario": user_data.tipo_usuario.value,
                "territorio_id": user_data.territorio_id or 1,  # Território padrão
                "telefone": user_data.telefone,
                "nome_social": user_data.nome_social,
                "nome_indigena": user_data.nome_indigena,
                "idade": user_data.idade,
                "principal_atuacao": user_data.principal_atuacao,
                "aldeia_comunidade": user_data.aldeia_comunidade,
                "localizacao_territorio": user_data.localizacao_territorio,
                "aceite_lgpd": 1 if user_data.aceite_lgpd else 0
            }
            
            oracle_manager.execute_insert(insert_query, user_params)
            
            # Buscar usuário criado
            created_user = self.get_user_by_email(user_data.email)
            
            # Gerar token
            token_data = {
                "sub": str(created_user["id"]),
                "email": created_user["email"],
                "tipo_usuario": created_user["tipo_usuario"]
            }
            access_token = self.create_access_token(token_data)
            
            # Log de auditoria
            logger.info(f"✅ Usuário registrado: {user_data.email} - Tipo: {user_data.tipo_usuario}")
            
            return {
                "access_token": access_token,
                "token_type": "bearer",
                "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
                "user_info": {
                    "id": created_user["id"],
                    "nome": created_user["nome"],
                    "email": created_user["email"],
                    "tipo_usuario": created_user["tipo_usuario"],
                    "territorio_id": created_user["territorio_id"],
                    "telefone": created_user["telefone"],
                    "nome_social": created_user["nome_social"],
                    "nome_indigena": created_user["nome_indigena"],
                    "idade": created_user["idade"],
                    "principal_atuacao": created_user["principal_atuacao"],
                    "aldeia_comunidade": created_user["aldeia_comunidade"],
                    "localizacao_territorio": created_user["localizacao_territorio"],
                    "aceite_lgpd": created_user["aceite_lgpd"],
                    "status": created_user["status"],
                    "data_criacao": created_user["data_criacao"]
                }
            }
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"❌ Erro ao registrar usuário: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno no registro do usuário"
            )
    
    def authenticate_user(self, login_data: UserLogin) -> Dict[str, Any]:
        """Autenticar usuário"""
        try:
            # Buscar usuário
            user = self.get_user_by_email(login_data.email)
            
            if not user:
                logger.warning(f"❌ Tentativa de login com email não cadastrado: {login_data.email}")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Email ou senha incorretos"
                )
            
            # Verificar senha
            if not self.verify_password(login_data.senha, user["senha_hash"]):
                logger.warning(f"❌ Tentativa de login com senha incorreta: {login_data.email}")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Email ou senha incorretos"
                )
            
            # Verificar status do usuário
            if user["status"] != "ativo":
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Usuário {user['status']}. Entre em contato com o administrador."
                )
            
            # Atualizar última atualização
            update_query = """
                UPDATE USUARIOS 
                SET ULTIMA_ATUALIZACAO = CURRENT_TIMESTAMP 
                WHERE ID = :user_id
            """
            oracle_manager.execute_insert(update_query, {"user_id": user["id"]})
            
            # Gerar token
            token_data = {
                "sub": str(user["id"]),
                "email": user["email"],
                "tipo_usuario": user["tipo_usuario"]
            }
            access_token = self.create_access_token(token_data)
            
            # Log de auditoria
            logger.info(f"✅ Login realizado: {login_data.email} - Tipo: {user['tipo_usuario']}")
            
            return {
                "access_token": access_token,
                "token_type": "bearer",
                "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
                "user_info": {
                    "id": user["id"],
                    "nome": user["nome"],
                    "email": user["email"],
                    "tipo_usuario": user["tipo_usuario"],
                    "territorio_id": user["territorio_id"],
                    "telefone": user["telefone"],
                    "nome_social": user["nome_social"],
                    "nome_indigena": user["nome_indigena"],
                    "idade": user["idade"],
                    "principal_atuacao": user["principal_atuacao"],
                    "aldeia_comunidade": user["aldeia_comunidade"],
                    "localizacao_territorio": user["localizacao_territorio"],
                    "aceite_lgpd": user["aceite_lgpd"],
                    "status": user["status"],
                    "data_criacao": user["data_criacao"]
                }
            }
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"❌ Erro na autenticação: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno na autenticação"
            )
    
    def get_user_by_id(self, user_id: int) -> Optional[Dict[str, Any]]:
        """Buscar usuário por ID"""
        try:
            query = """
                SELECT u.ID, u.NOME, u.EMAIL, u.SENHA_HASH, u.TIPO_USUARIO, 
                       u.TERRITORIO_ID, u.TELEFONE, u.NOME_SOCIAL, u.NOME_INDIGENA,
                       u.IDADE, u.PRINCIPAL_ATUACAO, u.ALDEIA_COMUNIDADE,
                       u.LOCALIZACAO_TERRITORIO, u.ACEITE_LGPD, u.STATUS, u.DATA_CRIACAO,
                       t.NOME as TERRITORIO_NOME
                FROM USUARIOS u
                LEFT JOIN TERRITORIOS t ON u.TERRITORIO_ID = t.ID
                WHERE u.ID = :user_id
                AND u.STATUS = 'ativo'
            """
            
            result = oracle_manager.execute_query(query, {"user_id": user_id})
            
            if result:
                row = result[0]
                return {
                    "id": row[0],
                    "nome": row[1],
                    "email": row[2],
                    "senha_hash": row[3],
                    "tipo_usuario": row[4],
                    "territorio_id": row[5],
                    "telefone": row[6],
                    "nome_social": row[7],
                    "nome_indigena": row[8],
                    "idade": row[9],
                    "principal_atuacao": row[10],
                    "aldeia_comunidade": row[11],
                    "localizacao_territorio": row[12],
                    "aceite_lgpd": bool(row[13]) if row[13] is not None else False,
                    "status": row[14],
                    "data_criacao": row[15],
                    "territorio_nome": row[16]
                }
            
            return None
            
        except Exception as e:
            logger.error(f"❌ Erro ao buscar usuário por ID: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )
    
    def verify_access_token(self, token: str) -> Dict[str, Any]:
        """Verificar token de acesso e retornar dados do usuário"""
        try:
            payload = self.verify_token(token)
            if not payload:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token inválido ou expirado",
                    headers={"WWW-Authenticate": "Bearer"}
                )
            
            user_id = int(payload.get("sub"))
            user = self.get_user_by_id(user_id)
            
            if not user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Usuário não encontrado",
                    headers={"WWW-Authenticate": "Bearer"}
                )
            
            return {
                "id": user["id"],
                "email": user["email"],
                "tipo_usuario": user["tipo_usuario"]
            }
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"❌ Erro ao verificar token: {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inválido",
                headers={"WWW-Authenticate": "Bearer"}
            )
    
    def update_user_profile(self, user_id: int, profile_data: UserProfileUpdate) -> Dict[str, Any]:
        """Atualizar perfil do usuário no Oracle"""
        try:
            # Preparar campos para atualização
            update_fields = []
            params = {"user_id": user_id}
            
            if profile_data.nome_social is not None:
                update_fields.append("NOME_SOCIAL = :nome_social")
                params["nome_social"] = profile_data.nome_social
            
            if profile_data.nome_indigena is not None:
                update_fields.append("NOME_INDIGENA = :nome_indigena")
                params["nome_indigena"] = profile_data.nome_indigena
            
            if profile_data.idade is not None:
                update_fields.append("IDADE = :idade")
                params["idade"] = profile_data.idade
            
            if profile_data.principal_atuacao is not None:
                update_fields.append("PRINCIPAL_ATUACAO = :principal_atuacao")
                params["principal_atuacao"] = profile_data.principal_atuacao
            
            if profile_data.aldeia_comunidade is not None:
                update_fields.append("ALDEIA_COMUNIDADE = :aldeia_comunidade")
                params["aldeia_comunidade"] = profile_data.aldeia_comunidade
            
            if profile_data.localizacao_territorio is not None:
                update_fields.append("LOCALIZACAO_TERRITORIO = :localizacao_territorio")
                params["localizacao_territorio"] = profile_data.localizacao_territorio
            
            if not update_fields:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Nenhum campo para atualizar"
                )
            
            # Query de atualização
            update_query = f"""
                UPDATE USUARIOS 
                SET {', '.join(update_fields)}, ULTIMA_ATUALIZACAO = CURRENT_TIMESTAMP
                WHERE ID = :user_id
            """
            
            # Executar atualização
            oracle_manager.execute_insert(update_query, params)
            
            # Buscar usuário atualizado
            user = self.get_user_by_id(user_id)
            if not user:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Usuário não encontrado após atualização"
                )
            
            logger.info(f"✅ Perfil do usuário {user_id} atualizado com sucesso")
            
            return {
                "id": user["id"],
                "nome": user["nome"],
                "email": user["email"],
                "nome_social": user["nome_social"],
                "nome_indigena": user["nome_indigena"],
                "idade": user["idade"],
                "principal_atuacao": user["principal_atuacao"],
                "aldeia_comunidade": user["aldeia_comunidade"],
                "localizacao_territorio": user["localizacao_territorio"],
                "tipo_usuario": user["tipo_usuario"],
                "status": user["status"]
            }
            
        except Exception as e:
            logger.error(f"❌ Erro ao atualizar perfil do usuário {user_id}: {e}")
            if isinstance(e, HTTPException):
                raise
            
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno ao atualizar perfil"
            )

# Instância global do serviço
auth_service = AuthService() 